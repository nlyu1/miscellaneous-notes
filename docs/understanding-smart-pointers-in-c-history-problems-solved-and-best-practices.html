<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>3 Understanding Smart Pointers in C++: History, Problems Solved, and Best Practices | Miscellany</title>
  <meta name="description" content="3 Understanding Smart Pointers in C++: History, Problems Solved, and Best Practices | Miscellany" />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="3 Understanding Smart Pointers in C++: History, Problems Solved, and Best Practices | Miscellany" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="3 Understanding Smart Pointers in C++: History, Problems Solved, and Best Practices | Miscellany" />
  
  
  

<meta name="author" content="Nicholas Lyu" />


<meta name="date" content="2025-07-19" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="building-c-projects.html"/>
<link rel="next" href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="docker.html"><a href="docker.html"><i class="fa fa-check"></i><b>1</b> Docker</a>
<ul>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#basic-commands"><i class="fa fa-check"></i>Basic commands</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#dockerfile"><i class="fa fa-check"></i>Dockerfile</a></li>
<li class="chapter" data-level="1.1" data-path="docker.html"><a href="docker.html#docker-compose"><i class="fa fa-check"></i><b>1.1</b> Docker compose</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#publishing-images"><i class="fa fa-check"></i>Publishing images</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#explanation-from-chatgpt"><i class="fa fa-check"></i>Explanation from ChatGPT</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="docker.html"><a href="docker.html#which-dockerfile-is-used-do-i-see-the-build-logs"><i class="fa fa-check"></i><b>1.1.1</b> 1. Which Dockerfile is used? Do I see the build logs?</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#what-happens-when-you-run-docker-compose-up"><i class="fa fa-check"></i>2. What happens when you run <code>docker compose up</code>?</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#what-happens-when-you-run-docker-compose-down"><i class="fa fa-check"></i>3. What happens when you run <code>docker compose down</code>?</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="building-c-projects.html"><a href="building-c-projects.html"><i class="fa fa-check"></i><b>2</b> Building C++ Projects</a>
<ul>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#cmake"><i class="fa fa-check"></i>CMake</a>
<ul>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#installing-cmake"><i class="fa fa-check"></i>Installing CMake</a></li>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#scikit-build-core"><i class="fa fa-check"></i>Scikit-build-core</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#smart-pointers"><i class="fa fa-check"></i>Smart pointers</a>
<ul>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#smart-pointer-deep-research"><i class="fa fa-check"></i>Smart Pointer deep research</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><i class="fa fa-check"></i><b>3</b> Understanding Smart Pointers in C++: History, Problems Solved, and Best Practices</a>
<ul>
<li class="chapter" data-level="3.1" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#background-origins-of-smart-pointers-in-c"><i class="fa fa-check"></i><b>3.1</b> Background: Origins of Smart Pointers in C++</a></li>
<li class="chapter" data-level="3.2" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#the-problems-with-raw-pointers-and-how-smart-pointers-fix-them"><i class="fa fa-check"></i><b>3.2</b> The Problems with Raw Pointers (and How Smart Pointers Fix Them)</a></li>
<li class="chapter" data-level="3.3" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#types-of-smart-pointers-in-modern-c"><i class="fa fa-check"></i><b>3.3</b> Types of Smart Pointers in Modern C++</a></li>
<li class="chapter" data-level="3.4" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#polymorphism-dynamic-dispatch-and-smart-pointers"><i class="fa fa-check"></i><b>3.4</b> Polymorphism, Dynamic Dispatch, and Smart Pointers</a></li>
<li class="chapter" data-level="3.5" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#modern-best-practices-for-using-smart-pointers"><i class="fa fa-check"></i><b>3.5</b> Modern Best Practices for Using Smart Pointers</a></li>
<li class="chapter" data-level="3.6" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#using-pointers-and-smart-pointers-in-function-interfaces"><i class="fa fa-check"></i><b>3.6</b> Using Pointers and Smart Pointers in Function Interfaces</a>
<ul>
<li class="chapter" data-level="3.6.1" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#passing-smart-pointers-to-functions-parameters"><i class="fa fa-check"></i><b>3.6.1</b> Passing Smart Pointers to Functions (Parameters)</a></li>
<li class="chapter" data-level="3.6.2" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#returning-pointers-or-smart-pointers-from-functions"><i class="fa fa-check"></i><b>3.6.2</b> Returning Pointers or Smart Pointers from Functions</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#factory-methods-modern-c-and-pybind"><i class="fa fa-check"></i>Factory methods, modern C++, and PyBind</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><i class="fa fa-check"></i><b>4</b> Factory Methods, Modern C++ Practices, and Pybind11 for Polymorphic Interfaces</a>
<ul>
<li class="chapter" data-level="4.1" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#factory-methods-in-c-design"><i class="fa fa-check"></i><b>4.1</b> 1. Factory Methods in C++ Design</a></li>
<li class="chapter" data-level="4.2" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#modern-c-tools-and-practices-for-safe-performant-code"><i class="fa fa-check"></i><b>4.2</b> 2. Modern C++ Tools and Practices for Safe, Performant Code</a></li>
<li class="chapter" data-level="4.3" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#best-practices-for-pybind11-with-polymorphic-c-interfaces"><i class="fa fa-check"></i><b>4.3</b> 3. Best Practices for Pybind11 with Polymorphic C++ Interfaces</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#exposing-c-classes-and-inheritance-to-python"><i class="fa fa-check"></i><b>4.3.1</b> <strong>Exposing C++ Classes and Inheritance to Python</strong></a></li>
<li class="chapter" data-level="4.3.2" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#memory-management-and-ownership-between-c-and-python"><i class="fa fa-check"></i><b>4.3.2</b> <strong>Memory Management and Ownership between C++ and Python</strong></a></li>
<li class="chapter" data-level="4.3.3" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#allowing-python-to-override-c-virtual-functions-trampoline-classes"><i class="fa fa-check"></i><b>4.3.3</b> <strong>Allowing Python to Override C++ Virtual Functions (Trampoline Classes)</strong></a></li>
<li class="chapter" data-level="4.3.4" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#end-to-end-example-and-best-practices-summary"><i class="fa fa-check"></i><b>4.3.4</b> <strong>End-to-End Example and Best Practices Summary</strong></a></li>
</ul></li>
<li class="chapter" data-level="" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#c-history"><i class="fa fa-check"></i>C++ history</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="bibliography.html"><a href="bibliography.html"><i class="fa fa-check"></i>Bibliography</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Miscellany</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices" class="section level1 hasAnchor" number="3">
<h1><span class="header-section-number">3</span> Understanding Smart Pointers in C++: History, Problems Solved, and Best Practices<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#understanding-smart-pointers-in-c-history-problems-solved-and-best-practices" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="background-origins-of-smart-pointers-in-c" class="section level2 hasAnchor" number="3.1">
<h2><span class="header-section-number">3.1</span> Background: Origins of Smart Pointers in C++<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#background-origins-of-smart-pointers-in-c" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In the early days of C++, memory management was done with raw pointers and explicit <code>new</code>/<code>delete</code> calls. This manual approach was error-prone – forgetting to delete memory led to <strong>memory leaks</strong>, and deleting twice or using an invalid pointer led to <strong>crashes</strong>. To address these issues, the concept of <strong>smart pointers</strong> was developed. Smart pointers are objects that simulate raw pointers but also automatically manage memory (and other resources) to prevent common bugs. They were <strong>popularized in C++ in the early 1990s</strong> as a response to criticism that C++ lacked automatic garbage collection. In other words, C++ smart pointers were created to provide safer, automated memory management (RAII) in a language without built-in garbage collection.</p>
<p>The first smart pointer in C++’s standard library was <code>std::auto_ptr</code>, introduced in the late 90s (formally in the 2003 standard). <code>auto_ptr</code> was a simple RAII pointer that <em>automatically deleted</em> its owned object when it went out of scope. However, it had flawed <em>copy semantics</em>: copying an <code>auto_ptr</code> <strong>transferred ownership</strong> (leaving the source empty) instead of duplicating, which was confusing and made it incompatible with standard containers. Due to these issues, <code>auto_ptr</code> was <strong>deprecated in C++11</strong> and ultimately removed in C++17.</p>
<p>Modern C++ (since C++11) introduced a new suite of smart pointers – <strong><code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code></strong> – largely inspired by prior practice in the Boost library. C++11 “fixed” <code>auto_ptr</code> by replacing it with <code>unique_ptr</code> for single-ownership and adding <code>shared_ptr</code>/<code>weak_ptr</code> for shared-ownership use cases. These modern smart pointers leverage C++11 features (like move semantics) to manage ownership more safely and efficiently than <code>auto_ptr</code> did.</p>
</div>
<div id="the-problems-with-raw-pointers-and-how-smart-pointers-fix-them" class="section level2 hasAnchor" number="3.2">
<h2><span class="header-section-number">3.2</span> The Problems with Raw Pointers (and How Smart Pointers Fix Them)<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#the-problems-with-raw-pointers-and-how-smart-pointers-fix-them" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Raw pointers in C/C++ are powerful but come with no automatic memory management. Developers must manually <code>delete</code> any <code>new</code>’d memory, which is error-prone. <strong>Memory leaks</strong> occur if a code path skips a needed <code>delete</code> (e.g. due to an exception or logic error). <strong>Dangling pointers</strong> occur if an object is deleted while someone still has a pointer to it. <strong>Double deletions</strong> or freeing invalid memory can happen if multiple pointers mistakenly manage the same object. These issues made robust memory management difficult in large, complex code.</p>
<p>Smart pointers address these problems using RAII (Resource Acquisition Is Initialization) and other mechanisms:</p>
<ul>
<li><p><strong>Automatic Deallocation (RAII)</strong>: A smart pointer object owns a heap allocation and is responsible for deleting it when the smart pointer goes out of scope. This guarantees that allocated memory is freed <em>exactly once</em>, at the right time, even if exceptions are thrown. For example, <code>std::unique_ptr</code> and <code>std::shared_ptr</code> will call <code>delete</code> on their managed object in their destructors, preventing leaks. By tying the object’s lifetime to a smart pointer’s scope, we avoid both leaks and premature frees.</p></li>
<li><p><strong>Unique Ownership or Reference Counting</strong>: Smart pointers keep track of who “owns” an object:</p>
<ul>
<li><strong>Unique ownership:</strong> <code>std::unique_ptr</code> represents sole ownership. It cannot be copied (only moved), so there is always exactly one owner responsible for deletion. This prevents the ambiguity of multiple deletes – only the unique owner deletes the object.</li>
<li><strong>Shared ownership:</strong> <code>std::shared_ptr</code> allows multiple pointers to share ownership of the same object via an internal <strong>reference count</strong>. The object is deleted when the last <code>shared_ptr</code> owning it is destroyed. This prevents dangling pointers in common scenarios – if two parts of code share an object, it won’t be freed until <em>both</em> have finished using it. However, shared pointers introduce a small overhead (a control block with the ref-count) and require care to avoid reference cycles (which <code>std::weak_ptr</code> solves; see below).</li>
</ul></li>
<li><p><strong>Exception Safety:</strong> With raw pointers, an exception thrown between a <code>new</code> and <code>delete</code> can leak memory. Smart pointers guard against this by ensuring the <code>delete</code> happens in their destructor no matter what. For example, if you allocate an object into a <code>unique_ptr</code> or <code>shared_ptr</code>, you don’t need a <code>delete</code> statement at all – the smart pointer’s destructor will clean up even if an exception is thrown, thus preventing leaks in error paths.</p></li>
<li><p><strong>Better Semantics:</strong> Smart pointers make ownership explicit. Code that uses a <code>unique_ptr</code> or <code>shared_ptr</code> clearly communicates if a function or class assumes ownership of a resource. This clarity can prevent bugs. For instance, when you see a function taking a <code>unique_ptr</code> parameter, you know it expects to take ownership (as opposed to a raw pointer parameter, where it’s unclear if the function will copy, delete, or just use the pointer). In essence, smart pointers encode the <em>ownership contract</em> in the type system.</p></li>
</ul>
<p>In summary, smart pointers were introduced to <strong>make memory management safer and easier</strong> in C++. They <strong>automate object destruction</strong> (preventing leaks) and <strong>coordinate ownership</strong> (preventing double-delete and dangling pointers). In languages with garbage collection (Java, C#, etc.), the runtime would handle this; in C++, smart pointers are a way to achieve deterministic, safer memory cleanup without a garbage collector.</p>
</div>
<div id="types-of-smart-pointers-in-modern-c" class="section level2 hasAnchor" number="3.3">
<h2><span class="header-section-number">3.3</span> Types of Smart Pointers in Modern C++<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#types-of-smart-pointers-in-modern-c" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Modern C++ provides several smart pointer classes in the <code>&lt;memory&gt;</code> header, each addressing different use cases:</p>
<ul>
<li><p><strong><code>std::unique_ptr&lt;T&gt;</code>:</strong> A unique_ptr owns a heap-allocated object exclusively. It cannot be copied, only moved, meaning you can transfer ownership but never accidentally have two unique_ptrs owning the same object. When a unique_ptr is destroyed (or reset/reassigned), it deletes the object it manages. This is ideal for the common case of a single owner. <code>unique_ptr</code> is lightweight (typically the size of a raw pointer) since it doesn’t require a reference count. It’s the go-to smart pointer for exclusive ownership and replaces the old <code>auto_ptr</code> (which had flawed copying behavior). Best practices in modern C++ dictate using <code>unique_ptr</code> (usually created with <code>std::make_unique</code>) for owning dynamically allocated objects, instead of raw <code>new</code>/<code>delete</code> calls. Example usage: <code>auto ptr = std::make_unique&lt;Foo&gt;();</code> gives you a unique_ptr that will delete the <code>Foo</code> when it goes out of scope.</p></li>
<li><p><strong><code>std::shared_ptr&lt;T&gt;</code>:</strong> A shared_ptr holds a pointer to a heap object and allows <strong>multiple owners</strong> via reference counting. Copies of a shared_ptr point to the same object and increase the internal count; when a shared_ptr is destroyed or reset, it decreases the count, and when the count drops to zero the object is deleted. This is useful when you <em>truly need</em> shared ownership semantics – e.g. an object that is used by multiple parts of a program with independent lifetimes. Shared pointers incur some overhead for thread-safe reference counting and a control block to manage the object’s lifetime. They also can suffer from cyclic references (if two objects reference each other via shared_ptr, they won’t free unless broken manually), which is what <code>std::weak_ptr</code> addresses. In modern C++, you typically use <code>std::make_shared</code> to create shared_ptrs (which efficiently allocates the control block and object in one go). <strong>Use shared_ptr only when ownership must be shared</strong>; otherwise prefer unique_ptr for simplicity and performance.</p></li>
<li><p><strong><code>std::weak_ptr&lt;T&gt;</code>:</strong> weak_ptr is a companion to shared_ptr. It is not an owner, but rather a safe observer of an object managed by shared_ptr. A weak_ptr does not increase the reference count, so it won’t prolong the object’s lifetime. However, you can check if the object still exists (<code>weak_ptr.expired()</code>) or obtain a temporary shared_ptr (<code>weak_ptr.lock()</code>) if it’s still alive. weak_ptrs are used to break reference cycles and to safely refer to objects that might be deleted. For example, in a graph or observer pattern, you might have a weak_ptr to avoid keeping an object alive unintentionally. If you attempt to lock a weak_ptr to a destroyed object, you get an empty shared_ptr instead of dereferencing a dangling raw pointer – this avoids dangling pointer issues.</p></li>
<li><p><em>(Historical)</em> <strong><code>std::auto_ptr&lt;T&gt;</code>:</strong> As mentioned, auto_ptr was the first attempt at a smart pointer (standardized in C++98/03) but had issues. It’s now obsolete, superseded by unique_ptr. Modern code <strong>should not use auto_ptr</strong> (it’s removed in C++17). We mention it only for historical context – use unique_ptr instead.</p></li>
</ul>
<p>Beyond these, C++ and libraries offer other specialized smart pointers (like <code>std::scoped_ptr</code> in Boost, or <code>std::shared_ptr</code> with custom deleters for arrays, etc.), but the core three (unique, shared, weak) cover most needs. With these tools, <strong>manual <code>new</code> and <code>delete</code> are largely unwarranted in modern C++</strong>: you allocate with <code>make_unique</code>/<code>make_shared</code> and let the smart pointers manage deletion.</p>
</div>
<div id="polymorphism-dynamic-dispatch-and-smart-pointers" class="section level2 hasAnchor" number="3.4">
<h2><span class="header-section-number">3.4</span> Polymorphism, Dynamic Dispatch, and Smart Pointers<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#polymorphism-dynamic-dispatch-and-smart-pointers" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Smart pointers work seamlessly with C++’s polymorphism (inheritance and virtual functions), just like raw pointers do. Polymorphic <strong>dynamic dispatch</strong> in C++ requires using pointers or references to base classes so that virtual function calls resolve to the derived class implementations at runtime. You can use smart pointers to hold polymorphic objects and still get proper dynamic dispatch. For example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb11-1" tabindex="-1"></a><span class="kw">struct</span> Base <span class="op">{</span> <span class="kw">virtual</span> <span class="dt">void</span> doSomething<span class="op">();</span> <span class="kw">virtual</span> <span class="op">~</span>Base<span class="op">(){}</span> <span class="op">};</span></span>
<span id="cb11-2"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb11-2" tabindex="-1"></a><span class="kw">struct</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span> <span class="dt">void</span> doSomething<span class="op">()</span> <span class="kw">override</span><span class="op">;</span> <span class="co">/* ... */</span> <span class="op">};</span></span>
<span id="cb11-3"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb11-3" tabindex="-1"></a></span>
<span id="cb11-4"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb11-4" tabindex="-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Base<span class="op">&gt;</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Derived<span class="op">&gt;();</span> </span>
<span id="cb11-5"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb11-5" tabindex="-1"></a>ptr<span class="op">-&gt;</span>doSomething<span class="op">();</span>  <span class="co">// calls Derived::doSomething() via Base pointer (dynamic dispatch)</span></span></code></pre></div>
<p>In the above snippet, <code>ptr</code> is a <code>unique_ptr&lt;Base&gt;</code> that actually holds a <code>Derived</code>. Calling <code>ptr-&gt;doSomething()</code> correctly invokes the overridden method in <code>Derived</code> thanks to the virtual function. The important thing to remember is to <strong>give your base class a virtual destructor</strong> if you plan to delete derived objects through a base pointer (raw or smart) – this ensures the derived destructor runs. In the case of unique_ptr, its destructor will call <code>delete</code> on a <code>Base*</code>, so <code>Base::~Base</code> must be virtual to allow <code>Derived</code> to be destroyed fully. (With shared_ptr, a similar caution applies, though <code>make_shared&lt;Derived&gt;</code> internally knows to call the correct destructor; still, it’s good practice to have a virtual destructor in polymorphic base classes.)</p>
<p>For casting between polymorphic types, C++ provides <code>dynamic_cast</code> (runtime-checked downcast) and <code>static_cast</code> (compile-time, unchecked). With smart pointers:</p>
<ul>
<li><p>For <code>unique_ptr</code>, there isn’t a built-in casting function. If you need to downcast a <code>unique_ptr&lt;Base&gt;</code> to <code>unique_ptr&lt;Derived&gt;</code>, you’ll have to do it manually (and carefully). One approach is to use <code>dynamic_cast</code> on the raw pointer and construct a new unique_ptr, e.g.:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb12-1" tabindex="-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Base<span class="op">&gt;</span> basePtr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Derived<span class="op">&gt;();</span></span>
<span id="cb12-2"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb12-2" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>Derived<span class="op">*</span> d <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Derived<span class="op">*&gt;(</span>basePtr<span class="op">.</span>get<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb12-3" tabindex="-1"></a>    <span class="co">// Use d, but basePtr still owns the object.</span></span>
<span id="cb12-4"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb12-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This lets you <em>observe</em> the object as a <code>Derived</code> if it really is that type. If you actually need to <strong>transfer ownership</strong> as a different type, you could release the pointer and recapture it in a new unique_ptr of the derived type, but that’s rarely needed and can be dangerous if the cast is wrong. In practice, frequent casting might indicate a design issue – consider using virtual functions or a variant instead of downcasting.</p></li>
<li><p>For <code>shared_ptr</code>, there <strong>are</strong> standard casting utilities: <code>std::dynamic_pointer_cast&lt;T&gt;(sp)</code> and <code>std::static_pointer_cast&lt;T&gt;(sp)</code>. These create a new <code>shared_ptr&lt;T&gt;</code> from a <code>shared_ptr&lt;U&gt;</code> by casting the underlying pointer. For example, if you have <code>std::shared_ptr&lt;Base&gt; sp = std::make_shared&lt;Derived&gt;();</code>, you can do:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb13-1" tabindex="-1"></a><span class="kw">auto</span> derivedSP <span class="op">=</span> <span class="bu">std::</span>dynamic_pointer_cast<span class="op">&lt;</span>Derived<span class="op">&gt;(</span>sp<span class="op">);</span></span>
<span id="cb13-2"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb13-2" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>derivedSP<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb13-3" tabindex="-1"></a>    <span class="co">// cast succeeded, use derivedSP as shared_ptr&lt;Derived&gt;</span></span>
<span id="cb13-4"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb13-4" tabindex="-1"></a>    derivedSP<span class="op">-&gt;</span>someDerivedMethod<span class="op">();</span></span>
<span id="cb13-5"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#cb13-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>dynamic_pointer_cast</code> will return an empty shared_ptr if the object isn’t actually of the target type. Notably, this new shared_ptr <strong>shares ownership</strong> with the original – the reference count is not duplicated but shared, so you won’t double-delete. This is safer than extracting a raw pointer and using <code>dynamic_cast</code> on it, which gives you a raw pointer that you might accidentally delete or not know if it’s owned. With dynamic_pointer_cast, the object stays managed by shared_ptr and the ref-count is properly maintained (the example above would increment the use count while <code>derivedSP</code> exists).</p></li>
</ul>
<p>In summary, smart pointers support polymorphism just as raw pointers do. Use a <code>unique_ptr&lt;Base&gt;</code> or <code>shared_ptr&lt;Base&gt;</code> to point to derived instances when you need polymorphic behavior. Just remember the rule about virtual destructors for base classes. And if downcasting is needed, prefer the smart pointer casting functions for shared_ptr, or avoid downcasting if possible by designing appropriate virtual functions.</p>
</div>
<div id="modern-best-practices-for-using-smart-pointers" class="section level2 hasAnchor" number="3.5">
<h2><span class="header-section-number">3.5</span> Modern Best Practices for Using Smart Pointers<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#modern-best-practices-for-using-smart-pointers" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>With the introduction of smart pointers, C++ developers have converged on some best practices to write safer and clearer code:</p>
<ul>
<li><p><strong>Use Smart Pointers for Ownership</strong>: In modern C++, you should rarely (if ever) call <code>delete</code> explicitly. If you allocate something with <code>new</code>, immediately put the raw pointer into a <code>unique_ptr</code> or <code>shared_ptr</code> so it will be correctly deleted later. The C++ Core Guidelines state: <em>“Prefer <code>unique_ptr</code> over raw pointers for owning memory”</em>, and generally advise using objects (including smart pointers) to manage resources. Raw pointers are now typically used only for <em>non-owning</em> references or in low-level code, not for expressing ownership.</p></li>
<li><p><strong><code>std::unique_ptr</code> as the Default Choice</strong>: Use unique_ptr for dynamically allocated objects whenever you have a single owning reference. It has zero overhead beyond a raw pointer and clearly conveys sole ownership. You can still transfer ownership by using <code>std::move</code> on the unique_ptr (for example, returning a unique_ptr from a function or storing it in another unique_ptr). Always favor unique_ptr unless you specifically need shared ownership or a polymorphic behavior that shared_ptr provides (like being able to copy the pointer freely). In short, <strong>unique_ptr is the go-to smart pointer</strong> for most cases of heap allocation.</p></li>
<li><p><strong><code>std::shared_ptr</code> for Shared Ownership</strong>: Use shared_ptr only when you truly need multiple parts of the code to own a pointer (meaning the object should persist as long as <em>anyone</em> needs it). Classic use cases might be in observer patterns, caches, or passing objects across threads where ownership is shared. Be mindful of performance and lifetime: shared_ptr uses atomic reference counting, which has a cost. If you use shared_ptr everywhere by default, you may introduce unnecessary overhead and complexity. So, <strong>use shared_ptr sparingly</strong>, and document why an object has to have shared ownership. When you do use shared_ptr, also consider whether a design could lead to cyclic references – if so, use weak_ptr for the back-reference to break the cycle.</p></li>
<li><p><strong>Use <code>std::make_unique</code> and <code>std::make_shared</code></strong>: These factory functions (C++14 for make_unique, C++11 for make_shared) should be used instead of calling <code>new</code> directly. For example, do <code>auto p = std::make_unique&lt;Foo&gt;(args);</code> rather than <code>Foo* p = new Foo(args);</code>. Not only do they make code concise, they also ensure exception safety in construction and, in the case of make_shared, can be more efficient (one allocation for both control block and object). The only caveat: <code>make_shared</code> might slightly delay the freeing of memory in some weak_ptr scenarios (due to control block and object being one allocation), but this is a minor point. Overall, use these helpers to create smart pointers.</p></li>
<li><p><strong>Avoid <code>auto_ptr</code>, raw <code>new</code>, and raw owning pointers</strong>: As mentioned, <code>auto_ptr</code> is deprecated/removed. Likewise, avoid using naked <code>new</code> and <code>delete</code> in application code – they should be wrapped in smart pointers or other RAII containers. If you find yourself writing <code>new</code> a lot, ask if a smart pointer or a standard container (like <code>std::vector</code> or <code>std::string</code> which manage their memory internally) would do the job. Raw pointers can be used for non-owning access (more on that below), but never let raw pointers be the sole owner of dynamic memory in modern code unless you have a very good reason.</p></li>
<li><p><strong>Custom Deleters and Other Resources</strong>: smart pointers are not limited to managing <code>new</code> allocations. You can supply a custom deleter to <code>unique_ptr</code>/<code>shared_ptr</code> to manage other resources (files, sockets, malloc/free, etc.). This is an advanced but powerful feature: for example, <code>std::unique_ptr&lt;FILE, decltype(&amp;fclose)&gt; fileptr(fopen(...), &amp;fclose);</code> will call <code>fclose</code> when it goes out of scope. This turns many C-style resource management tasks into safe RAII patterns using the same smart pointer concept.</p></li>
<li><p><strong>Thread Safety</strong>: Note that shared_ptr’s control block operations are thread-safe (you can copy shared_ptr on multiple threads), which is another reason to use it in multithreaded scenarios needing shared access. unique_ptr, on the other hand, is not thread-safe to share between threads (you must transfer it between threads or use synchronization, since it can’t be copied). Usually each thread would have its own unique_ptr or share a common object via shared_ptr. This is just to be aware that shared_ptr has some overhead to support thread safety.</p></li>
<li><p><strong>Don’t Overuse Smart Pointers</strong>: While smart pointers help manage dynamic memory, remember that not everything needs to be on the heap. Use stack objects or plain values where appropriate. Overusing heap allocations (even with smart pointers) can lead to performance issues. Smart pointers are a tool to manage necessary dynamic objects, not a mandate to heap-allocate everything.</p></li>
</ul>
<p>In essence, <strong>modern C++ style = use RAII and smart pointers for resource management</strong>. This greatly reduces memory bugs and makes ownership semantics explicit. The remaining question is how to use smart pointers in function interfaces, which we cover next.</p>
</div>
<div id="using-pointers-and-smart-pointers-in-function-interfaces" class="section level2 hasAnchor" number="3.6">
<h2><span class="header-section-number">3.6</span> Using Pointers and Smart Pointers in Function Interfaces<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#using-pointers-and-smart-pointers-in-function-interfaces" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>One area that can be confusing is how to pass smart pointers to functions or return them, especially with const and reference qualifiers involved. The guiding principle is: <strong>only pass or return a smart pointer if you need to communicate ownership semantics</strong>. If not, prefer using a raw pointer or reference to refer to the object. Let’s break down scenarios for function parameters and return types:</p>
<div id="passing-smart-pointers-to-functions-parameters" class="section level3 hasAnchor" number="3.6.1">
<h3><span class="header-section-number">3.6.1</span> Passing Smart Pointers to Functions (Parameters)<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#passing-smart-pointers-to-functions-parameters" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Ask, <em>“Does the function need to take ownership of the object? Or share ownership? Or neither?”</em> The answer determines how you should pass the argument:</p>
<ul>
<li><p><strong>Function <em>takes ownership</em> (sink):</strong> If the function is expected to assume ownership of a dynamically allocated object (meaning the caller should give up ownership), use a smart pointer parameter by value. Typically, this means a parameter of type <code>std::unique_ptr&lt;T&gt;</code> (not reference) so that the function will receive and own the pointer, and the caller must <code>std::move</code> their unique_ptr when calling. For example: <code>void f(std::unique_ptr&lt;Widget&gt; ptr)</code>. The caller does <code>f(std::move(myPtr));</code> and after the call, <code>myPtr</code> is null and the function’s copy owns the object. This pattern clearly indicates a transfer of ownership. (For shared ownership transfer, you could also pass a <code>std::shared_ptr</code> by value, which would increment the ref count, meaning the function now co-owns the object. But if the function is meant to exclusively take a newly created object, unique_ptr is more appropriate.)</p></li>
<li><p><strong>Function <em>reseats or modifies the smart pointer</em>:</strong> If the function needs to modify the caller’s smart pointer itself – e.g. perhaps set it to null or make it point to a different object – then pass the smart pointer by non-const reference. For unique_ptr, this would be <code>void f(std::unique_ptr&lt;T&gt;&amp; ptr)</code>. This tells the caller that the function might change their unique_ptr (reset it or replace it). The function can do <code>ptr.reset()</code> or <code>ptr = std::make_unique&lt;T&gt;(...)</code> internally, affecting the caller’s unique_ptr. (You <strong>cannot</strong> pass by value here, because that would only modify a copy.) Similarly, for shared_ptr, <code>f(std::shared_ptr&lt;T&gt;&amp; p)</code> would allow the function to reassign the caller’s shared_ptr (though this is less common). Note: you <strong>cannot</strong> bind an rvalue (temporary) to a non-const lvalue reference, so the caller must pass an actual lvalue shared_ptr/unique_ptr variable to these functions (not a temporary or <code>std::move</code>, which is good because we don’t want to accidentally move in this case).</p></li>
<li><p><strong>Function <em>shares ownership</em> (wants to use and possibly keep a copy):</strong> If a function is not taking exclusive ownership but wants to <strong>participate in shared ownership</strong>, you can pass a <code>std::shared_ptr&lt;T&gt;</code> by value. This way, the function gets its own shared_ptr pointing to the object (bumping the ref count), and can store it or use it freely without worrying if the caller’s copy goes away. For example <code>void f(std::shared_ptr&lt;Foo&gt; sp)</code>. Inside f, <code>sp.use_count()</code> would be at least 2 (one in caller, one in callee) until f ends or unless f stores it elsewhere. This strategy ensures the object stays alive for the duration of the function (and beyond, if f stores the shared_ptr). Keep in mind copying a shared_ptr is relatively heavy (atomic refcount increment/decrement), so do this only if needed.</p></li>
<li><p><strong>Function only needs to <em>observe/use</em> the object (no ownership change):</strong> This is the most common case – the function just needs to read or manipulate the object without taking ownership. In this scenario, <strong>do not pass a smart pointer at all</strong>; instead, pass a raw pointer or reference to the object. For example, <code>void f(const Widget* w)</code> or <code>void f(Widget&amp; w)</code> if you expect a valid object. This makes it clear that f is not responsible for lifetime management; it’s just using the object. Passing a smart pointer here would add no benefit – it would just obscure the fact that you only needed to use the object. In fact, passing a <code>const std::unique_ptr&lt;T&gt;&amp;</code> or <code>const std::shared_ptr&lt;T&gt;&amp;</code> to just use the object is considered <strong>needlessly convoluted</strong>, because the smart pointer is then just “a useless wrapper around a naked pointer” in that context. The C++ Core Guidelines put it plainly: *“For general use, take T* or T&amp; arguments rather than smart pointers”* when you don’t need to manipulate ownership. This way, your function’s interface focuses on the object itself, not how it’s managed.</p></li>
</ul>
<p>In practice, if you have a <code>std::unique_ptr&lt;Foo&gt; myPtr</code> and you want to call a function that just uses <code>Foo</code>, you’d do something like <code>void useFoo(const Foo&amp; obj);</code> and call <code>useFoo(*myPtr);</code> – or if the function takes a <code>Foo*</code>, call <code>useFoo(myPtr.get());</code>. This does the right thing: it passes a pointer/reference to the actual <code>Foo</code> without transferring ownership, and the lifetime is guaranteed because the unique_ptr remains in scope keeping the object alive.</p>
<p><strong>What about const correctness?</strong> If the function shouldn’t modify the object, use a pointer-to-const or reference-to-const (<code>const Foo*</code> or <code>const Foo&amp;</code>). If the function shouldn’t (or needn’t) modify the smart pointer itself, you might be tempted to pass a <code>const std::unique_ptr&lt;Foo&gt;&amp;</code>. As discussed, that prevents the function from moving or resetting the unique_ptr, but it <em>still allows modifying the pointed object</em> (since the unique_ptr would give access to a non-const Foo). This is another reason to prefer passing the object or a raw pointer directly – e.g. <code>f(const Foo* ptr)</code> expresses that the function won’t modify the Foo via this pointer. In short, use <code>const</code> on the pointer or reference to signify read-only access to the pointee, rather than wrapping the pointer in a const smart pointer reference, which complicates matters. One Stack Overflow answer nicely summarizes: passing <code>const unique_ptr&lt;T&gt;&amp;</code> “is just using the unique_ptr as a useless wrapper around a naked pointer,” so you might as well pass a naked pointer or reference to begin with. This yields clearer semantics and solves any const-correctness issues.</p>
<p>To recap parameter guidelines:</p>
<ul>
<li>Use <code>unique_ptr&lt;T&gt;</code> by value when the function <strong>takes ownership</strong> (caller gives it up).</li>
<li>Use <code>unique_ptr&lt;T&gt;&amp;</code> (rarely <code>const&amp;</code>) if the function needs to <strong>modify or reseat</strong> the caller’s smart pointer.</li>
<li>Use <code>shared_ptr&lt;T&gt;</code> by value if the function should <strong>share ownership</strong> (it will make a copy to keep the object alive).</li>
<li>Use <code>shared_ptr&lt;T&gt;&amp;</code> if the function might <strong>reseat</strong> the shared pointer (e.g. assign a new shared_ptr to it).</li>
<li>Do <em>not</em> use smart pointers in the param list just to access the object – in that case, use raw <code>T*</code> or <code>const T&amp;</code> (and document that the function does not take ownership). The raw pointer can be seen as “I just need to observe or use this object, it must outlive the call but I’m not owning it.”</li>
</ul>
</div>
<div id="returning-pointers-or-smart-pointers-from-functions" class="section level3 hasAnchor" number="3.6.2">
<h3><span class="header-section-number">3.6.2</span> Returning Pointers or Smart Pointers from Functions<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#returning-pointers-or-smart-pointers-from-functions" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>For function return types, the choice of raw pointer vs smart pointer also boils down to ownership semantics:</p>
<ul>
<li><p><strong>Returning a new heap object:</strong> If a function is creating a new object that the caller will own, the modern best practice is to return a <code>std::unique_ptr&lt;T&gt;</code> rather than a raw <code>T*</code>. For example, a factory function might be <code>std::unique_ptr&lt;Foo&gt; createFoo(args...) { return std::make_unique&lt;Foo&gt;(args...); }</code>. This makes it clear the caller takes ownership via the unique_ptr (and no manual delete is needed). It also provides exception safety (if creation fails, no need to worry about delete in the caller). In older C++, such functions would often return a raw pointer and put the burden on the caller to eventually delete it, which is less safe. <strong>Returning unique_ptr communicates the transfer of ownership clearly</strong> and is the recommended approach. The caller can then decide to keep it in a unique_ptr or even convert to a shared_ptr if needed (by moving it into a shared_ptr). The key is that using unique_ptr in the interface prevents forgetting to manage the memory.</p></li>
<li><p><strong>Returning shared ownership:</strong> If a function is returning an object that it will share ownership of with the caller, return a <code>std::shared_ptr&lt;T&gt;</code>. An example might be a function that retrieves an object from a cache or subsystem where the object is managed by a shared_ptr internally; returning a shared_ptr lets the caller hold a reference without worrying that the object might disappear. It also makes it clear that the object could be shared elsewhere. Keep in mind, returning shared_ptr increases the ref count (or constructs a new shared_ptr) so there’s some overhead. Only use shared_ptr in returns if sharing is intended. If the function always creates a fresh object just for the caller, unique_ptr is usually sufficient (the caller can share it later if needed).</p></li>
<li><p><strong>Returning a reference or raw pointer to an existing object:</strong> Sometimes a function returns a reference or pointer to an object that it <em>still owns</em>. For example, <code>Foo&amp; getFoo()</code> or <code>Foo* getFoo()</code> might return a pointer/reference to an internal object (like an element of a container or a singleton). In this case, you are not transferring ownership, just providing access. <strong>Be very careful</strong> with this – you must ensure that the object outlives the return and clearly document that the caller should not delete it. A raw pointer return can be appropriate to indicate “non-owning reference” (in fact, the Core Guidelines say returning a <code>T*</code> can be used to indicate the caller should not free it – it’s just a “position” or reference). If you do this, consider using tools like <code>gsl::not_null</code> or at least assert that the returned pointer isn’t null if that’s expected. Never return a pointer or reference to a local object (that leads to dangling pointers).</p></li>
<li><p><strong>Returning <code>nullptr</code> to signal “not found” or similar:</strong> If using raw pointers for non-owning returns, a common pattern is returning nullptr to indicate a missing result (e.g., search functions returning <code>T*</code>). This is fine for non-owning scenarios. If using smart pointers, returning an empty <code>unique_ptr</code> or <code>shared_ptr</code> can also indicate a null result. But be mindful that returning a <code>shared_ptr</code> just to use its null to indicate “not found” is overkill if ownership isn’t needed – a raw pointer can do the same with less overhead.</p></li>
</ul>
<p>In summary, <strong>match the return type to the ownership semantics</strong>:</p>
<ul>
<li>Use <code>unique_ptr&lt;T&gt;</code> to return a newly created object that the caller will own (exclusive ownership transfer).</li>
<li>Use <code>shared_ptr&lt;T&gt;</code> to return an object that is shared between caller and callee.</li>
<li>Use raw <code>T*</code> or <code>T&amp;</code> to return references to objects managed elsewhere (but document lifetime assumptions and never return pointers to locals). If a raw pointer is returned from a function that created an object, that’s typically a code smell – it implies the caller must delete it, which is not exception-safe or clear (prefer returning unique_ptr in that case).</li>
</ul>
<p>Finally, regarding const-correctness in returns: returning a <code>const T*</code> or <code>const T&amp;</code> can indicate the caller should not modify the object through that pointer/reference. Smart pointers can also be const, e.g. returning <code>std::shared_ptr&lt;const T&gt;</code> if you want to present a read-only shared object. This will prevent the caller from modifying T (the pointed-to object) via that pointer (they’d only have const access). Such usage is less common but can be used to enforce an object’s immutability from the caller’s perspective.</p>
<hr />
<p>To wrap up, <strong>smart pointers</strong> in C++ were introduced to make memory management safer by automating resource cleanup and clarifying ownership semantics. They originated in the 90s (with early reference-counting ideas) and became standard in the late 90s/2000s with <code>auto_ptr</code>, evolving to the robust <code>unique_ptr</code>/<code>shared_ptr</code> we use today. Smart pointers solve problems of memory leaks and dangling pointers by ensuring objects are properly destroyed when no longer needed. Modern best practices suggest using <code>unique_ptr</code> as a default for owning pointers, <code>shared_ptr</code> only when needed for sharing, and using raw pointers/references for non-owning uses to keep interfaces clear. When using inheritance, smart pointers behave like raw pointers (respecting polymorphism), and C++ provides casting utilities for shared_ptr to navigate class hierarchies safely. By following these practices – choosing the right smart pointer and passing/returning it correctly – you can write C++ code that is both safer (less prone to memory errors) and easier to understand in terms of object ownership and lifespan. </p>
</div>
</div>
<div id="factory-methods-modern-c-and-pybind" class="section level2 unnumbered hasAnchor">
<h2>Factory methods, modern C++, and PyBind<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#factory-methods-modern-c-and-pybind" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Great, I’ll prepare a comprehensive guide that covers:</p>
<ol style="list-style-type: decimal">
<li>Factory methods in modern C++: what they are, how they work with polymorphism and smart pointers, and when to use or avoid them, with concrete examples.</li>
<li>Best practices and toolchains for rigorous, research-grade C++ projects—especially those interfacing with Python and involving computation, linear algebra, and deep learning. This includes CMake, build systems, testing frameworks, and static/dynamic analysis tools.</li>
<li>A clear, detailed tutorial on Pybind11 bindings for polymorphic class hierarchies in C++: how to use trampoline classes, manage object ownership, expose factory methods, and correctly bind base/derived class interfaces so they can be used transparently from Python. I’ll use simplified, annotated code inspired by real-world cases like OpenSpiel to keep it clear.</li>
</ol>
<p>I’ll let you know as soon as it’s ready.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="building-c-projects.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
