<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>4 Factory Methods, Modern C++ Practices, and Pybind11 for Polymorphic Interfaces | Miscellany</title>
  <meta name="description" content="4 Factory Methods, Modern C++ Practices, and Pybind11 for Polymorphic Interfaces | Miscellany" />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="4 Factory Methods, Modern C++ Practices, and Pybind11 for Polymorphic Interfaces | Miscellany" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4 Factory Methods, Modern C++ Practices, and Pybind11 for Polymorphic Interfaces | Miscellany" />
  
  
  

<meta name="author" content="Nicholas Lyu" />


<meta name="date" content="2025-07-19" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"/>
<link rel="next" href="bibliography.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="docker.html"><a href="docker.html"><i class="fa fa-check"></i><b>1</b> Docker</a>
<ul>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#basic-commands"><i class="fa fa-check"></i>Basic commands</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#dockerfile"><i class="fa fa-check"></i>Dockerfile</a></li>
<li class="chapter" data-level="1.1" data-path="docker.html"><a href="docker.html#docker-compose"><i class="fa fa-check"></i><b>1.1</b> Docker compose</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#publishing-images"><i class="fa fa-check"></i>Publishing images</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#explanation-from-chatgpt"><i class="fa fa-check"></i>Explanation from ChatGPT</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="docker.html"><a href="docker.html#which-dockerfile-is-used-do-i-see-the-build-logs"><i class="fa fa-check"></i><b>1.1.1</b> 1. Which Dockerfile is used? Do I see the build logs?</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#what-happens-when-you-run-docker-compose-up"><i class="fa fa-check"></i>2. What happens when you run <code>docker compose up</code>?</a></li>
<li class="chapter" data-level="" data-path="docker.html"><a href="docker.html#what-happens-when-you-run-docker-compose-down"><i class="fa fa-check"></i>3. What happens when you run <code>docker compose down</code>?</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="building-c-projects.html"><a href="building-c-projects.html"><i class="fa fa-check"></i><b>2</b> Building C++ Projects</a>
<ul>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#cmake"><i class="fa fa-check"></i>CMake</a>
<ul>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#installing-cmake"><i class="fa fa-check"></i>Installing CMake</a></li>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#scikit-build-core"><i class="fa fa-check"></i>Scikit-build-core</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#smart-pointers"><i class="fa fa-check"></i>Smart pointers</a>
<ul>
<li class="chapter" data-level="" data-path="building-c-projects.html"><a href="building-c-projects.html#smart-pointer-deep-research"><i class="fa fa-check"></i>Smart Pointer deep research</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><i class="fa fa-check"></i><b>3</b> Understanding Smart Pointers in C++: History, Problems Solved, and Best Practices</a>
<ul>
<li class="chapter" data-level="3.1" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#background-origins-of-smart-pointers-in-c"><i class="fa fa-check"></i><b>3.1</b> Background: Origins of Smart Pointers in C++</a></li>
<li class="chapter" data-level="3.2" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#the-problems-with-raw-pointers-and-how-smart-pointers-fix-them"><i class="fa fa-check"></i><b>3.2</b> The Problems with Raw Pointers (and How Smart Pointers Fix Them)</a></li>
<li class="chapter" data-level="3.3" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#types-of-smart-pointers-in-modern-c"><i class="fa fa-check"></i><b>3.3</b> Types of Smart Pointers in Modern C++</a></li>
<li class="chapter" data-level="3.4" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#polymorphism-dynamic-dispatch-and-smart-pointers"><i class="fa fa-check"></i><b>3.4</b> Polymorphism, Dynamic Dispatch, and Smart Pointers</a></li>
<li class="chapter" data-level="3.5" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#modern-best-practices-for-using-smart-pointers"><i class="fa fa-check"></i><b>3.5</b> Modern Best Practices for Using Smart Pointers</a></li>
<li class="chapter" data-level="3.6" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#using-pointers-and-smart-pointers-in-function-interfaces"><i class="fa fa-check"></i><b>3.6</b> Using Pointers and Smart Pointers in Function Interfaces</a>
<ul>
<li class="chapter" data-level="3.6.1" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#passing-smart-pointers-to-functions-parameters"><i class="fa fa-check"></i><b>3.6.1</b> Passing Smart Pointers to Functions (Parameters)</a></li>
<li class="chapter" data-level="3.6.2" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#returning-pointers-or-smart-pointers-from-functions"><i class="fa fa-check"></i><b>3.6.2</b> Returning Pointers or Smart Pointers from Functions</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html"><a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html#factory-methods-modern-c-and-pybind"><i class="fa fa-check"></i>Factory methods, modern C++, and PyBind</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><i class="fa fa-check"></i><b>4</b> Factory Methods, Modern C++ Practices, and Pybind11 for Polymorphic Interfaces</a>
<ul>
<li class="chapter" data-level="4.1" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#factory-methods-in-c-design"><i class="fa fa-check"></i><b>4.1</b> 1. Factory Methods in C++ Design</a></li>
<li class="chapter" data-level="4.2" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#modern-c-tools-and-practices-for-safe-performant-code"><i class="fa fa-check"></i><b>4.2</b> 2. Modern C++ Tools and Practices for Safe, Performant Code</a></li>
<li class="chapter" data-level="4.3" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#best-practices-for-pybind11-with-polymorphic-c-interfaces"><i class="fa fa-check"></i><b>4.3</b> 3. Best Practices for Pybind11 with Polymorphic C++ Interfaces</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#exposing-c-classes-and-inheritance-to-python"><i class="fa fa-check"></i><b>4.3.1</b> <strong>Exposing C++ Classes and Inheritance to Python</strong></a></li>
<li class="chapter" data-level="4.3.2" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#memory-management-and-ownership-between-c-and-python"><i class="fa fa-check"></i><b>4.3.2</b> <strong>Memory Management and Ownership between C++ and Python</strong></a></li>
<li class="chapter" data-level="4.3.3" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#allowing-python-to-override-c-virtual-functions-trampoline-classes"><i class="fa fa-check"></i><b>4.3.3</b> <strong>Allowing Python to Override C++ Virtual Functions (Trampoline Classes)</strong></a></li>
<li class="chapter" data-level="4.3.4" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#end-to-end-example-and-best-practices-summary"><i class="fa fa-check"></i><b>4.3.4</b> <strong>End-to-End Example and Best Practices Summary</strong></a></li>
</ul></li>
<li class="chapter" data-level="" data-path="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#c-history"><i class="fa fa-check"></i>C++ history</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="bibliography.html"><a href="bibliography.html"><i class="fa fa-check"></i>Bibliography</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Miscellany</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces" class="section level1 hasAnchor" number="4">
<h1><span class="header-section-number">4</span> Factory Methods, Modern C++ Practices, and Pybind11 for Polymorphic Interfaces<a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="factory-methods-in-c-design" class="section level2 hasAnchor" number="4.1">
<h2><span class="header-section-number">4.1</span> 1. Factory Methods in C++ Design<a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#factory-methods-in-c-design" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>What are Factory Methods?</strong> – A Factory Method is a creational design pattern that provides an interface for creating objects, but allows the subclasses or separate functions to decide which concrete class to instantiate. In essence, you call a <em>factory method</em> instead of calling a constructor directly. This indirection lets you create objects without specifying the exact class of the object being created. The factory method typically returns a pointer or smart pointer to an abstract base class or interface that the concrete products implement. This promotes <strong>loose coupling</strong>: client code calls the factory interface and doesn’t need to know about the concrete subclasses, making it easier to extend or change implementations later.</p>
<p><strong>How are they used in C++?</strong> – In C++, factory methods can be implemented in different styles:</p>
<ul>
<li><p><em>Static factory functions in a class:</em> A class can provide static methods that construct instances in specialized ways. For example, consider a 2D vector class that can be initialized either from Cartesian coordinates <code>(x,y)</code> or polar coordinates <code>(angle, magnitude)</code>. You cannot have two constructors with the same signature, so you can use named static factory methods:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-1" tabindex="-1"></a><span class="kw">struct</span> Vec2 <span class="op">{</span></span>
<span id="cb14-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-2" tabindex="-1"></a>    <span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb14-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-3" tabindex="-1"></a>    <span class="co">// private constructor to force use of factories</span></span>
<span id="cb14-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-4" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb14-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-5" tabindex="-1"></a>    Vec2<span class="op">(</span><span class="dt">float</span> x_val<span class="op">,</span> <span class="dt">float</span> y_val<span class="op">)</span> <span class="op">:</span> x<span class="op">(</span>x_val<span class="op">),</span> y<span class="op">(</span>y_val<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb14-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-6" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb14-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-7" tabindex="-1"></a>    <span class="at">static</span> Vec2 fromLinear<span class="op">(</span><span class="dt">float</span> x<span class="op">,</span> <span class="dt">float</span> y<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb14-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-8" tabindex="-1"></a>        <span class="cf">return</span> Vec2<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span> </span>
<span id="cb14-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-9" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-10" tabindex="-1"></a>    <span class="at">static</span> Vec2 fromPolar<span class="op">(</span><span class="dt">float</span> angle<span class="op">,</span> <span class="dt">float</span> magnitude<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb14-11"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-11" tabindex="-1"></a>        <span class="cf">return</span> Vec2<span class="op">(</span>magnitude <span class="op">*</span> cos<span class="op">(</span>angle<span class="op">),</span> magnitude <span class="op">*</span> sin<span class="op">(</span>angle<span class="op">));</span> </span>
<span id="cb14-12"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-12" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-13"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb14-13" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Here, <code>Vec2::fromLinear</code> and <code>Vec2::fromPolar</code> are factory methods that create <code>Vec2</code> objects in different ways. The caller can clearly indicate which construction they want, improving code clarity over using constructors (and avoiding the need for an impossible constructor overload). This is a simple form of the Factory Method pattern where the class is its own factory.</p></li>
<li><p><em>Factory function or class hierarchy:</em> More commonly associated with the formal <strong>Factory Method pattern</strong> (from the GoF design patterns), you might have an abstract creator with a virtual factory method, and multiple concrete creators. For example, an abstract <code>ShapeFactory</code> class could declare <code>virtual Shape* createShape() = 0</code>, and derived factory classes like <code>CircleFactory</code> override it to instantiate a <code>Circle</code>, while <code>SquareFactory</code> creates a <code>Square</code>. Client code uses a <code>ShapeFactory*</code> interface, not knowing which concrete factory it’s given, to obtain a new <code>Shape</code> and use it polymorphically. The key benefit is that the decision of <em>which</em> <code>Shape</code> subclass to create can be deferred until runtime (for example, based on user input or configuration) and encapsulated in the factory. The client just knows it’s getting a <code>Shape</code> pointer.</p>
<p>As a concrete example, if you have an abstract product class <code>Shape</code> (with a method like <code>draw()</code>), and concrete products <code>Circle</code> and <code>Square</code> implementing <code>Shape</code>, you can have:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-1" tabindex="-1"></a><span class="kw">class</span> ShapeFactory <span class="op">{</span></span>
<span id="cb15-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-2" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-3" tabindex="-1"></a>    <span class="kw">virtual</span> Shape<span class="op">*</span> createShape<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-4" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>ShapeFactory<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb15-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-5" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb15-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-6" tabindex="-1"></a><span class="kw">class</span> CircleFactory <span class="op">:</span> <span class="kw">public</span> ShapeFactory <span class="op">{</span></span>
<span id="cb15-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-7" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-8" tabindex="-1"></a>    Shape<span class="op">*</span> createShape<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">new</span> Circle<span class="op">();</span> <span class="op">}</span></span>
<span id="cb15-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-9" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb15-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-10" tabindex="-1"></a><span class="kw">class</span> SquareFactory <span class="op">:</span> <span class="kw">public</span> ShapeFactory <span class="op">{</span></span>
<span id="cb15-11"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-11" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-12"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-12" tabindex="-1"></a>    Shape<span class="op">*</span> createShape<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">new</span> Square<span class="op">();</span> <span class="op">}</span></span>
<span id="cb15-13"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb15-13" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Now the client can do:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb16-1" tabindex="-1"></a>ShapeFactory<span class="op">*</span> factory <span class="op">=</span> <span class="op">(</span>userWantsCircle <span class="op">?</span> <span class="kw">new</span> CircleFactory<span class="op">()</span> <span class="op">:</span> <span class="kw">new</span> SquareFactory<span class="op">());</span></span>
<span id="cb16-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb16-2" tabindex="-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Shape<span class="op">&gt;</span> shp<span class="op">(</span>factory<span class="op">-&gt;</span>createShape<span class="op">());</span></span>
<span id="cb16-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb16-3" tabindex="-1"></a>shp<span class="op">-&gt;</span>draw<span class="op">();</span></span></code></pre></div>
<p>The client code didn’t need to know which concrete <code>Shape</code> was created – that decision was made inside the factory method at runtime. This is the classic Factory Method pattern usage. (In practice, you might not even need separate <code>CircleFactory</code> classes; a simpler approach is often to use a single free function or static method with a <code>switch</code> or if-else to choose the concrete type based on a parameter.)</p></li>
<li><p><em>Free function factory:</em> In many C++ projects, a simpler approach is just a free function that returns a base-class pointer. For example, a factory function for a game AI might be:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb17-1" tabindex="-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Enemy<span class="op">&gt;</span> createEnemy<span class="op">(</span>EnemyType type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb17-2" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span>type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb17-3" tabindex="-1"></a>        <span class="cf">case</span> EnemyType<span class="op">::</span>Goblin<span class="op">:</span> <span class="cf">return</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Goblin<span class="op">&gt;();</span></span>
<span id="cb17-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb17-4" tabindex="-1"></a>        <span class="cf">case</span> EnemyType<span class="op">::</span>Dragon<span class="op">:</span> <span class="cf">return</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Dragon<span class="op">&gt;();</span></span>
<span id="cb17-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb17-5" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb17-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb17-6" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb17-7" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This function encapsulates the logic of which subclass to create. The key point is that <strong>the correct type to create is determined at runtime</strong> (here by the <code>EnemyType</code> value). The caller just gets a <code>std::unique_ptr&lt;Enemy&gt;</code> and doesn’t have to deal with the details. This is often called a <em>factory method</em> as well (though it might not involve a whole class hierarchy of factories). It’s perfectly fine in C++ to implement the factory pattern with free functions or static methods if you don’t need a full Factory <em>class</em> hierarchy – in many cases a simple function is sufficient.</p></li>
</ul>
<p><strong>When (and when not) to use factory methods:</strong> Use factory methods when object creation is non-trivial or you want to decouple <em>what</em> you create from <em>how</em> it’s created. Scenarios include: when you have a family of related classes and you need to choose one at runtime (e.g., different game <code>State</code> objects based on a config string), or when construction involves complex setup that you want to centralize and possibly reuse. Factories can also improve code readability by giving descriptive names to creation processes (like <code>Vec2::fromPolar</code>) and by avoiding exposure of <code>new</code> and <code>delete</code> in user code.</p>
<p>However, <strong>do not overuse factories</strong> when they’re not needed. If object construction is simple and doesn’t vary, calling a constructor directly is clearer. Introducing a factory for a class that could be directly constructed just adds indirection and complexity for no gain. In particular, avoid factories for “trivially easy to construct objects” – it’s over-engineering. For example, if you find yourself writing a factory that just does <code>return new X(args);</code> and nothing else, consider whether a direct <code>new X(args)</code> (or better, a smart pointer or stack allocation) in the caller would be sufficient. Factories also come with a slight runtime cost (dynamic dispatch or branching) and additional classes to maintain, so you want to use them only when they buy you clear benefits (like flexibility or hiding complexity). As one source notes: <em>“Avoid using the Factory Method pattern when your object creation process is straightforward and doesn’t require additional complexity… Don’t implement it if you don’t need to hide concrete implementation details, as this can lead to unnecessary overhead.”</em>.</p>
<p>In summary, factory methods are a powerful design technique in C++ (and other OOP languages) to abstract away and manage object creation. They shine when the creation logic is complex or when the code needs to work with a base interface while deferring the choice of concrete subclass to runtime. But if those conditions don’t apply, simple construction is usually preferable for clarity and performance.</p>
<p><strong>Concrete example in practice:</strong> A real-world use might be something like OpenSpiel’s game loaders: OpenSpiel defines a base <code>Game</code> class and various derived game classes. It provides a factory function <code>LoadGame(std::string game_name)</code> which internally decides which derived game class to instantiate (Poker, Chess, etc.) based on the string, and returns a pointer (or smart pointer) to <code>Game</code>. The user simply calls <code>auto game = LoadGame("chess")</code> and gets a polymorphic <code>Game</code> object without needing to know the exact class name for chess. This is a typical factory pattern usage – the library can add new games (new classes) without changing the code that calls <code>LoadGame</code>, since that code only deals with the base <code>Game</code> interface.</p>
</div>
<div id="modern-c-tools-and-practices-for-safe-performant-code" class="section level2 hasAnchor" number="4.2">
<h2><span class="header-section-number">4.2</span> 2. Modern C++ Tools and Practices for Safe, Performant Code<a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#modern-c-tools-and-practices-for-safe-performant-code" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Moving beyond “bare bones” C++ (manual arrays, raw pointers, etc.), modern C++ development involves a rich toolchain and set of practices to write safer and faster code. Here are some important tools and concepts you should be aware of:</p>
<ul>
<li><p><strong>Smart Pointers and RAII:</strong> In modern C++, you should almost never use <code>new</code> and <code>delete</code> directly. Instead, use smart pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, etc.) and the RAII idiom (Resource Acquisition Is Initialization) to manage resources. RAII means owning resources in objects that automatically release them in their destructors. For memory, <code>unique_ptr</code> is a unique-ownership pointer that deletes the object when it goes out of scope; <code>shared_ptr</code> is a reference-counted pointer for shared ownership. These eliminate most memory leaks and make lifetime management easier. In fact, a common guideline is <strong>“Avoid raw new/delete, C-style arrays, and manual memory management unless absolutely necessary – use smart pointers and RAII for all resources (memory, file handles, sockets, etc.)”</strong>. This greatly reduces memory errors and makes code more robust.</p></li>
<li><p><strong>Use STL Containers instead of raw arrays:</strong> The C++ Standard Library provides containers like <code>std::vector</code>, <code>std::array</code>, <code>std::string</code>, <code>std::map</code>, etc., which handle memory management and sizing for you. Prefer these over raw C arrays or manual <code>malloc</code>. For example, <code>std::vector&lt;int&gt; data(n);</code> manages a dynamic array of <code>int</code> without you worrying about deleting it. These containers have bounds-checking (with <code>.at()</code>), iterators, and work with algorithms. Similarly, use algorithms like <code>std::sort</code>, <code>&lt;algorithm&gt;</code> library functions, rather than hand-writing loops for common tasks – they are well-tested and often optimized. <strong>Don’t reinvent the wheel</strong>: <em>“Prefer the Standard Library, especially the STL, which provides highly optimized and well-tested components. For example, use <code>std::vector</code> or <code>std::array</code> over raw C-style arrays, and use STL algorithms over hand-written loops where applicable.”</em>. This leads to safer and often faster code due to decades of optimization of these components.</p></li>
<li><p><strong>Modern C++ Language Features:</strong> Make use of language enhancements from C++11/C++14/C++17/C++20 which improve both safety and performance:</p>
<ul>
<li><strong>Auto and ranged for-loops:</strong> <code>auto</code> helps avoid type mismatches and makes code cleaner when types are long. Range-based for loops (<code>for(auto&amp; x : container)</code>) avoid index errors and make loops more expressive.</li>
<li><strong>Const-correctness:</strong> Use <code>const</code> pervasively for variables and function parameters that shouldn’t change. This catches bugs and enables compiler optimizations.</li>
<li><strong>Move semantics (rvalue references):</strong> Modern C++ allows you to move (steal) resources instead of copying, which is crucial for performance with large data (e.g., moving a large vector instead of copying it). Understand <code>std::move</code> and move constructors to avoid unnecessary deep copies.</li>
<li><strong>Concurrency libraries:</strong> C++11 introduced <code>&lt;thread&gt;</code>, <code>&lt;future&gt;</code>, <code>&lt;mutex&gt;</code> etc. If your computations can benefit from parallelism, you can use threads or higher-level tools like thread pools, or even parallel algorithms (C++17) to utilize multiple cores. However, be careful with thread safety and data races; use synchronization primitives or message-passing patterns as needed. Also consider high-level parallel frameworks or libraries (TBB, OpenMP) for numerically intensive code.</li>
<li><strong>Error handling:</strong> Prefer exceptions for error cases instead of error codes, in most high-level application logic (in performance-critical lower-level code, sometimes people avoid exceptions, but generally modern C++ uses exceptions for robustness). Also consider using standard types like <code>std::optional</code> or <code>std::variant</code> for representing optional values or variant types safely.</li>
</ul></li>
<li><p><strong>Build Systems and Package Managers:</strong> Unlike small single-file programs, larger C++ projects use build systems. You’ve discovered CMake, which is the de facto standard for C++ builds. CMake lets you manage compilation of multiple source files, manage dependencies, set up proper compiler flags for optimization, etc. For interfacing with Python, tools like <strong>scikit-build-core</strong> integrate CMake with Python’s packaging, making it easier to build C++ extensions as Python modules. This is very useful for projects that have a C++ back-end and a Python front-end (common in ML and scientific computing). Apart from CMake, be aware of package managers like <strong>Conan</strong> or <strong>vcpkg</strong>, which help manage C++ library dependencies (similar to pip in Python). They can save you from the pain of manually building and linking many libraries in large projects.</p></li>
<li><p><strong>Libraries for Scientific Computing:</strong> Given your interest in linear algebra and deep learning, you should leverage existing high-performance libraries:</p>
<ul>
<li><strong>Eigen</strong> – a hugely popular C++ template library for linear algebra (vectors, matrices, solvers). It’s <em>header-only</em> (no separate linking needed) and uses expression templates and SIMD instructions to achieve high performance on CPUs. Eigen is so well-regarded that it’s used inside major projects like <strong>TensorFlow and Stan</strong> for their linear algebra needs. In fact, “Eigen has been adopted for use within both the TensorFlow machine learning library and the Stan Math library, as well as at CERN”, which speaks to its performance and reliability. Using Eigen, you get Python-like matrix operations (+, -, * etc. overloaded for matrices) but with C++ performance (including vectorized operations with SSE/AVX). It saves you from writing low-level loops and enables writing math computations in a high-level, safer manner (no explicit memory allocation for intermediate results, since it cleverly avoids temporaries in many cases).</li>
<li><strong>BLAS/LAPACK and others:</strong> For certain heavy linear algebra tasks, you might use platform-optimized BLAS libraries (like Intel MKL, OpenBLAS). However, Eigen often is sufficient and more convenient. Other libraries like <strong>Armadillo</strong> (another C++ linear algebra lib), <strong>Boost.uBlas</strong>, or GPU-accelerated ones (CUDA libraries like cuBLAS, or Tensor libraries) are also available. For deep learning, you wouldn’t typically write everything from scratch – you might interface with libraries like <strong>PyTorch (libtorch)</strong> or <strong>TensorFlow C++ API</strong>, but if you do need to write custom C++ computations, use these established libraries for the heavy lifting.</li>
<li><strong>Visualization and I/O</strong>: If your project grows, also be aware of libraries for tasks like parsing (e.g., JSON libraries), visualization (maybe writing data to files that Python can plot, or using something like OpenCV for images), etc.</li>
</ul></li>
<li><p><strong>Performance Tools:</strong> To write <em>performant</em> C++ code, knowing the language and libraries is step one; step two is measuring and tuning. Get familiar with profilers (such as Valgrind’s callgrind, <code>perf</code> on Linux, or Visual Studio Profiler on Windows) to find bottlenecks. Also learn to use optimization flags (<code>-O2</code>, <code>-O3</code>) and how to measure the effect of changes. For numerical code, techniques like ensuring memory is contiguous and aligned (which libraries like Eigen handle for you) and minimizing allocations (reusing buffers, etc.) can be important. Modern C++ also has tools for heterogeneous computing (CUDA for GPU, SYCL for multi-backend), if you venture there.</p></li>
<li><p><strong>Safety and Debugging Tools:</strong> Modern C++ encourages writing safe code by design, but using tools is essential. For example, run your code with <strong>AddressSanitizer</strong> and <strong>UndefinedBehaviorSanitizer</strong> (compiler flags like <code>-fsanitize=address,undefined</code>) to catch memory errors (out-of-bounds, use-after-free, etc.) early. Use <strong>Valgrind</strong> to detect memory leaks. These tools are invaluable as projects scale. Writing <strong>unit tests</strong> (e.g., with Google Test) is also a best practice to ensure each component works and to catch regressions early. Static analysis tools (like clang-tidy or Cppcheck) and linters can automatically flag potential issues and enforce style or best practices. Many C++ projects also follow the <strong>C++ Core Guidelines</strong> which codify best practices; there are even checker tools for some of those rules.</p></li>
</ul>
<p>In summary, beyond the basics of arrays and pointers, modern C++ development involves using the standard library for common data structures and algorithms, leveraging smart pointers and RAII for memory safety, using tools like CMake for builds, and harnessing specialized libraries for heavy tasks like linear algebra. It also means keeping up with language improvements (C++17/20 features) that let you write cleaner and faster code. By combining these, you get the performance of C++ with much less of the traditional pitfalls of memory management and complexity. As one guideline succinctly puts it: use the “modern subset” of C++ – e.g., C++20+, no raw pointers if possible, no manual memory management, and plenty of help from libraries and static analysis. This will let you build <strong>performant, safe, and maintainable</strong> C++ projects, especially for computational tasks that interface with Python.</p>
</div>
<div id="best-practices-for-pybind11-with-polymorphic-c-interfaces" class="section level2 hasAnchor" number="4.3">
<h2><span class="header-section-number">4.3</span> 3. Best Practices for Pybind11 with Polymorphic C++ Interfaces<a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#best-practices-for-pybind11-with-polymorphic-c-interfaces" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Interfacing C++ and Python using <strong>pybind11</strong> is a powerful way to get the best of both worlds (C++ speed, Python ease). However, it can get tricky when you need to expose complex C++ designs – especially class hierarchies (inheritance), factory functions, and ownership of objects across the language boundary. Let’s break down the best practices for a scenario like OpenSpiel’s, where we have C++ polymorphic classes, some factory functions, and we want to use them from Python (possibly even subclass them in Python). We’ll cover how to expose classes and inheritance, manage object lifetimes safely, and allow method overrides between C++ and Python.</p>
<div id="exposing-c-classes-and-inheritance-to-python" class="section level3 hasAnchor" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> <strong>Exposing C++ Classes and Inheritance to Python</strong><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#exposing-c-classes-and-inheritance-to-python" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Pybind11 makes it straightforward to expose classes. For a simple class with no inheritance, you use <code>py::class_&lt;T&gt;(module, "ClassName")</code> and add <code>.def()</code> for its methods and constructors (<code>.def(py::init&lt;...&gt;())</code>). When dealing with inheritance (a base class and derived classes), pybind11 allows you to specify the base in the template parameters. For example, suppose we have:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-1" tabindex="-1"></a><span class="co">// C++ code</span></span>
<span id="cb18-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-2" tabindex="-1"></a><span class="kw">struct</span> Game <span class="op">{</span> </span>
<span id="cb18-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-3" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Game<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb18-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-4" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="bu">std::</span>string name<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb18-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-5" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> play<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb18-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-6" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb18-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-7" tabindex="-1"></a><span class="kw">struct</span> ChessGame <span class="op">:</span> <span class="kw">public</span> Game <span class="op">{</span></span>
<span id="cb18-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-8" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;Chess&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb18-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-9" tabindex="-1"></a>    <span class="dt">void</span> play<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Playing chess</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb18-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-10" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb18-11"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-11" tabindex="-1"></a><span class="kw">struct</span> PokerGame <span class="op">:</span> <span class="kw">public</span> Game <span class="op">{</span></span>
<span id="cb18-12"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-12" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;Poker&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb18-13"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-13" tabindex="-1"></a>    <span class="dt">void</span> play<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Playing poker</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb18-14"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-14" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb18-15"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-15" tabindex="-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Game<span class="op">&gt;</span> LoadGame<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> <span class="dt">game_type</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-16"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-16" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span><span class="dt">game_type</span> <span class="op">==</span> <span class="st">&quot;chess&quot;</span><span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>ChessGame<span class="op">&gt;();</span></span>
<span id="cb18-17"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-17" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span><span class="dt">game_type</span> <span class="op">==</span> <span class="st">&quot;poker&quot;</span><span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>PokerGame<span class="op">&gt;();</span></span>
<span id="cb18-18"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-18" tabindex="-1"></a>    <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;Unknown game type&quot;</span><span class="op">);</span></span>
<span id="cb18-19"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb18-19" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here <code>Game</code> is an abstract base class, and <code>ChessGame</code>/<code>PokerGame</code> are concrete derived classes. We also have a factory <code>LoadGame</code> that returns a <code>shared_ptr&lt;Game&gt;</code>.</p>
<p>To bind these with pybind11:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-1" tabindex="-1"></a><span class="kw">namespace</span> py <span class="op">=</span> pybind11<span class="op">;</span></span>
<span id="cb19-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-2" tabindex="-1"></a>PYBIND11_MODULE<span class="op">(</span>mygames<span class="op">,</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-3" tabindex="-1"></a>    <span class="co">// Bind the base class Game, use shared_ptr as holder type</span></span>
<span id="cb19-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-4" tabindex="-1"></a>    py<span class="op">::</span><span class="va">class_</span><span class="op">&lt;</span>Game<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Game<span class="op">&gt;&gt;(</span>m<span class="op">,</span> <span class="st">&quot;Game&quot;</span><span class="op">)</span></span>
<span id="cb19-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-5" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span><span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="op">&amp;</span>Game<span class="op">::</span>name<span class="op">)</span></span>
<span id="cb19-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-6" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span><span class="st">&quot;play&quot;</span><span class="op">,</span> <span class="op">&amp;</span>Game<span class="op">::</span>play<span class="op">);</span></span>
<span id="cb19-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-7" tabindex="-1"></a>    </span>
<span id="cb19-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-8" tabindex="-1"></a>    <span class="co">// Bind derived classes, specifying Game as the base</span></span>
<span id="cb19-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-9" tabindex="-1"></a>    py<span class="op">::</span><span class="va">class_</span><span class="op">&lt;</span>ChessGame<span class="op">,</span> Game<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>ChessGame<span class="op">&gt;&gt;(</span>m<span class="op">,</span> <span class="st">&quot;ChessGame&quot;</span><span class="op">)</span></span>
<span id="cb19-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-10" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span>py<span class="op">::</span>init<span class="op">&lt;&gt;());</span></span>
<span id="cb19-11"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-11" tabindex="-1"></a>    py<span class="op">::</span><span class="va">class_</span><span class="op">&lt;</span>PokerGame<span class="op">,</span> Game<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>PokerGame<span class="op">&gt;&gt;(</span>m<span class="op">,</span> <span class="st">&quot;PokerGame&quot;</span><span class="op">)</span></span>
<span id="cb19-12"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-12" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span>py<span class="op">::</span>init<span class="op">&lt;&gt;());</span></span>
<span id="cb19-13"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-13" tabindex="-1"></a>    </span>
<span id="cb19-14"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-14" tabindex="-1"></a>    <span class="co">// Bind the factory function</span></span>
<span id="cb19-15"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-15" tabindex="-1"></a>    m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;load_game&quot;</span><span class="op">,</span> <span class="op">&amp;</span>LoadGame<span class="op">,</span> py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;game_type&quot;</span><span class="op">));</span></span>
<span id="cb19-16"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb19-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A few important things to note in this binding code:</p>
<ul>
<li><p>We specified <code>std::shared_ptr&lt;...&gt;</code> as the holder type for these classes (the second template argument in <code>py::class_</code>). By default, pybind11 uses <code>std::unique_ptr&lt;T&gt;</code> as the holder for classes, but when dealing with class hierarchies and factory functions, using <code>std::shared_ptr</code> is often more convenient. It allows Python to share ownership of objects and easily handle polymorphic conversions. In the above, because <code>Game</code> uses <code>std::shared_ptr&lt;Game&gt;</code> as holder, any function returning a <code>std::shared_ptr&lt;Game&gt;</code> (like <code>LoadGame</code>) will automatically convert to a Python <code>Game</code> object that holds a shared pointer. Also, a <code>ChessGame*</code> can be converted to <code>Game</code> in Python since pybind11 knows ChessGame derives Game and both use compatible holders.</p></li>
<li><p>We listed <code>Game</code> as a base for <code>ChessGame</code> in the binding (<code>py::class_&lt;ChessGame, Game, ...&gt;</code>). This tells pybind11 about the inheritance relationship so that upcasts (ChessGame -&gt; Game) are understood. After this, if <code>load_game("chess")</code> returns a <code>Game</code> (actually a ChessGame under the hood), Python will see it as a <code>mygames.Game</code> instance. But dynamic dispatch still works: calling <code>game.name()</code> in Python will invoke <code>ChessGame::name()</code> in C++ due to C++ virtual dispatch.</p></li>
<li><p>We exposed <code>Game</code>’s methods (which are <code>virtual</code>) to Python. Pybind11 will allow calls on the base class instance, which actually invoke the derived override, as expected. This is straightforward since C++ handles virtual dispatch natively.</p></li>
</ul>
<p><strong>When not to expose derived classes separately:</strong> In some cases, you might choose <em>not</em> to expose <code>ChessGame</code> and <code>PokerGame</code> as Python-visible classes at all, if you want to treat them abstractly. You could just expose <code>Game</code> and the <code>load_game</code> function, and users get <code>Game</code> objects. This is fine if Python code never needs to explicitly construct or refer to <code>ChessGame</code>. In OpenSpiel’s case, they likely don’t expose each game class individually; they provide a factory to get games by name. Exposing the base class and factory is sufficient for usage. However, exposing the derived classes can be useful if you anticipate subclassing them in Python or wanting to inspect the concrete type on the Python side.</p>
</div>
<div id="memory-management-and-ownership-between-c-and-python" class="section level3 hasAnchor" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> <strong>Memory Management and Ownership between C++ and Python</strong><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#memory-management-and-ownership-between-c-and-python" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One of the trickiest aspects is managing object lifetimes across the boundary. Here are best practices:</p>
<ul>
<li><p><strong>Use smart pointers as holders:</strong> As shown, using <code>std::shared_ptr</code> (or the newer <code>py::smart_holder</code>) is recommended for classes, especially if instances may be created in C++ and passed to Python or vice versa. A shared pointer holder ensures that the C++ object isn’t deleted as long as Python has a reference to it (because the Python object will keep a shared_ptr). It also handles multiple references gracefully. If you used the default unique_ptr holder, you could still pass objects around, but you wouldn’t be able to easily create new C++ objects on the Python side to pass back into C++ (since unique_ptr can’t be copied). The <strong><code>py::smart_holder</code></strong> (used via <code>py::classh&lt;T&gt;</code> alias) introduced in pybind11 v2.6+ is even more powerful: it can manage both unique and shared pointers and avoids some pitfalls like slicing. For example, <code>py::class_&lt;Game, PyGame, py::smart_holder&gt;</code> (if we also want trampolines, see below) would be a safe default. Smart holder automatically keeps Python subclass alive when passed to C++, and supports conversions of both unique_ptr and shared_ptr. If using plain shared_ptr as we did above, it works in most cases but be mindful that passing a unique_ptr from C++ to Python wouldn’t be supported in that setup.</p></li>
<li><p><strong>Factory function return value policy:</strong> When binding a factory like <code>load_game</code> that returns a raw pointer or a smart pointer, you need to tell pybind11 how to convert it. If you return a <code>std::shared_ptr&lt;Game&gt;</code> directly (as in our example), and <code>Game</code> is registered with shared_ptr holder, everything is automatic. If instead your factory returned a raw <code>Game*</code>, you should specify a return value policy, typically <code>return_value_policy::take_ownership</code> (if the factory allocates a new object and transfers ownership to Python) or <code>reference</code>/<code>reference_internal</code> if appropriate. In practice, prefer returning smart pointers – it’s clearer and less error-prone since pybind11 can handle them directly.</p></li>
<li><p><strong>Keep-alive for cross-language references:</strong> A crucial scenario is when Python passes an object (especially a Python subclass of a C++ class) into a C++ function that stores it for later use. For instance, suppose <code>Game</code> had a method <code>registerCallback(GameObserver* obs)</code> to store an observer pointer. If a Python class extends <code>GameObserver</code> and you pass an instance, you must ensure Python’s object doesn’t get garbage-collected while C++ still holds the pointer. Pybind11 offers the <code>keep_alive&lt;&gt;</code> policy for this. For example:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb20-1" tabindex="-1"></a><span class="op">.</span>def<span class="op">(</span><span class="st">&quot;registerCallback&quot;</span><span class="op">,</span> <span class="op">&amp;</span>Game<span class="op">::</span>registerCallback<span class="op">,</span> py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;obs&quot;</span><span class="op">),</span> py<span class="op">::</span>keep_alive<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;());</span></span></code></pre></div>
<p>The <code>keep_alive&lt;1,2&gt;</code> tells pybind11 that the object at argument 2 (the observer) should be kept alive at least as long as the object at argument 1 (the <code>Game</code> <code>this</code> pointer) remains alive. This effectively increases the refcount or holds a reference internally to prevent premature deletion. In a Stack Overflow example, passing a Python-derived object into C++ and retrieving it later failed when not using <code>keep_alive</code>, because the temporary Python object was destroyed too soon. The solution was either to hold a Python reference or use <code>keep_alive</code>. So, whenever a C++ function stores a pointer to a Python object, use <code>keep_alive</code> (or manage the lifetimes by ensuring the Python object is held in a variable on the Python side).</p></li>
<li><p><strong>Avoiding slicing and multiple inheritance issues:</strong> If you allow Python subclasses (see next section), note that storing a base pointer to a Python subclass can lead to slicing if not handled properly. Pybind11’s <code>py::trampoline_self_life_support</code> (used in trampolines) and <code>smart_holder</code> work together to avoid this by ensuring the actual Python object stays around. Without going too deep: if you’re not using smart_holder, make sure to inherit <code>py::trampoline_self_life_support</code> in your trampoline classes (as pybind11 enforces). This helps keep the Python part alive when C++ only knows about the base part.</p></li>
</ul>
</div>
<div id="allowing-python-to-override-c-virtual-functions-trampoline-classes" class="section level3 hasAnchor" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> <strong>Allowing Python to Override C++ Virtual Functions (Trampoline Classes)</strong><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#allowing-python-to-override-c-virtual-functions-trampoline-classes" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If your library expects users to possibly subclass your C++ classes in Python (e.g., to implement a callback interface or an abstract class in Python), you need to use <strong>trampoline classes</strong> in pybind11. A trampoline class is a C++ class that inherits your C++ base and overrides virtual methods to redirect calls to Python.</p>
<p>For example, if <code>Game</code> had a virtual method <code>virtual void on_event(int x)</code>, and you want Python subclasses of <code>Game</code> to be able to override <code>on_event</code>, you would do something like:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-1" tabindex="-1"></a><span class="kw">struct</span> PyGame <span class="op">:</span> Game<span class="op">,</span> pybind11<span class="op">::</span>trampoline_self_life_support <span class="op">{</span></span>
<span id="cb21-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-2" tabindex="-1"></a>    <span class="kw">using</span> Game<span class="op">::</span>Game<span class="op">;</span> <span class="co">// inherit constructors if any</span></span>
<span id="cb21-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-4" tabindex="-1"></a>    <span class="co">// Override virtual methods to delegate to Python</span></span>
<span id="cb21-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-5" tabindex="-1"></a>    <span class="dt">void</span> on_event<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb21-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-6" tabindex="-1"></a>        PYBIND11_OVERRIDE<span class="op">(</span><span class="dt">void</span><span class="op">,</span> Game<span class="op">,</span> on_event<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb21-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-7" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-8" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb21-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-9" tabindex="-1"></a>        PYBIND11_OVERRIDE_PURE<span class="op">(</span><span class="bu">std::</span>string<span class="op">,</span> Game<span class="op">,</span> name<span class="op">,</span> <span class="co">/* no args */</span><span class="op">);</span></span>
<span id="cb21-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-10" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-11"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-11" tabindex="-1"></a>    <span class="co">// etc. for each virtual function you want Python to be able to override</span></span>
<span id="cb21-12"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb21-12" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Then bind <code>Game</code> with this trampoline:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb22-1" tabindex="-1"></a>py<span class="op">::</span><span class="va">class_</span><span class="op">&lt;</span>Game<span class="op">,</span> PyGame<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Game<span class="op">&gt;&gt;(</span>m<span class="op">,</span> <span class="st">&quot;Game&quot;</span><span class="op">)</span></span>
<span id="cb22-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb22-2" tabindex="-1"></a>    <span class="op">.</span>def<span class="op">(</span><span class="st">&quot;on_event&quot;</span><span class="op">,</span> <span class="op">&amp;</span>Game<span class="op">::</span>on_event<span class="op">)</span></span>
<span id="cb22-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb22-3" tabindex="-1"></a>    <span class="op">.</span>def<span class="op">(</span><span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="op">&amp;</span>Game<span class="op">::</span>name<span class="op">)</span></span>
<span id="cb22-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb22-4" tabindex="-1"></a>    <span class="co">// ... other defs ...</span></span>
<span id="cb22-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb22-5" tabindex="-1"></a><span class="op">;</span></span></code></pre></div>
<p>Key points about trampolines:</p>
<ul>
<li><p>The trampolines override the base class virtuals using the <code>PYBIND11_OVERRIDE</code> macro (or <code>_PURE</code> variant if the base method is pure virtual). This macro checks if the Python object has an override for the method; if yes, it calls it, otherwise (or for pure versions, if not overridden) it can call a default or throw.</p></li>
<li><p>The <code>Game</code> class in the binding is told that its alias (trampoline) is <code>PyGame</code> by that template parameter. That way, if a Python subclass is created, pybind11 will actually allocate a <code>PyGame</code> C++ object to back it, which can call back into Python.</p></li>
<li><p>Notice we included <code>pybind11::trampoline_self_life_support</code> as a base of <code>PyGame</code> – as mentioned, this is required to safely handle certain lifetime issues when using <code>std::unique_ptr</code> holders. Since we used shared_ptr, it might be less critical, but it’s a good practice as pybind11 mandates for trampolines with certain holders.</p></li>
<li><p>When binding, put the base class first, then the trampoline class in <code>py::class_&lt;&gt;</code> template parameters. Pybind11 documentation emphasizes the order: <code>py::class_&lt;Base, PyBase&gt;</code> means Base is the actual type for Python, and PyBase is the trampoline. All method definitions still refer to <code>&amp;Game::on_event</code> etc., <em>not</em> the trampoline’s methods.</p></li>
<li><p>After this setup, Python can do:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb23-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-1" tabindex="-1"></a><span class="kw">class</span> MyGame(Game):</span>
<span id="cb23-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb23-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-3" tabindex="-1"></a>        Game.<span class="fu">__init__</span>(<span class="va">self</span>)  <span class="co"># call base constructor if needed</span></span>
<span id="cb23-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-4" tabindex="-1"></a>    <span class="kw">def</span> on_event(<span class="va">self</span>, x):</span>
<span id="cb23-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-5" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Python handling event&quot;</span>, x)</span>
<span id="cb23-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-6" tabindex="-1"></a>    <span class="kw">def</span> name(<span class="va">self</span>):</span>
<span id="cb23-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-7" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;MyGame&quot;</span></span>
<span id="cb23-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-8" tabindex="-1"></a>g <span class="op">=</span> MyGame()</span>
<span id="cb23-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-9" tabindex="-1"></a>g.on_event(<span class="dv">42</span>)       <span class="co"># calls MyGame.on_event in Python</span></span>
<span id="cb23-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb23-10" tabindex="-1"></a>cpp_call_somehow(g)  <span class="co"># if C++ calls Game::on_event on g, it will route to Python override</span></span></code></pre></div>
<p>This bridging is complex under the hood, but pybind11 takes care of it via the trampoline. Note that if C++ will <em>store</em> <code>g</code> (as a <code>Game*</code> or <code>shared_ptr&lt;Game&gt;</code>), we must use the earlier-mentioned <code>keep_alive</code> or smart holder approach to ensure the <code>MyGame</code> Python object isn’t destroyed too early.</p></li>
</ul>
<p>One limitation: when you create Python subclasses like <code>MyGame</code>, pybind11 has to allocate a C++ <code>PyGame</code> object (since Python object needs a C++ backend). This means Python may succeed in instantiating a class that is abstract in C++ without implementing all pure virtuals. In our example, if <code>name()</code> was pure and Python class didn’t override it, what happens? The trampoline’s <code>PYBIND11_OVERRIDE_PURE</code> will throw a runtime error if called. But Python could still instantiate the class (because from Python’s perspective, it’s not abstract once bound). So the design principle “you cannot instantiate an abstract class” isn’t enforced on the Python side. This is a minor quirk – essentially, you have to rely on runtime errors if a pure virtual isn’t overridden. In practice, it’s not a big issue, but it’s good to be aware that Python classes can be created even if they don’t override everything (they just can’t successfully call the missing methods).</p>
<p><strong>Trampolines vs alternative approach:</strong> If you don’t need Python to subclass your C++ classes, you can avoid trampolines. For example, if <code>Game</code> is meant to be subclassed only in C++ and just used in Python, you can bind it without a trampoline. Only use trampolines if you want Python-side inheritance of that class. Trampolines do have a slight overhead, so pybind11 by default only initializes them when needed (like when a Python subclass is actually created) to avoid unnecessary cost.</p>
</div>
<div id="end-to-end-example-and-best-practices-summary" class="section level3 hasAnchor" number="4.3.4">
<h3><span class="header-section-number">4.3.4</span> <strong>End-to-End Example and Best Practices Summary</strong><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#end-to-end-example-and-best-practices-summary" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Putting it all together with an example (combining the above ideas):</p>
<p>Suppose we are designing a C++ library with an abstract base class <code>Game</code> and multiple game types. We want to expose this to Python such that users can load games by name, call methods on them, and even implement their own game in Python by subclassing <code>Game</code> (perhaps for quick prototyping).</p>
<p><strong>C++ side design:</strong></p>
<ul>
<li><code>Game</code> is an abstract class with some virtual methods (like <code>play()</code>).</li>
<li>Concrete games like <code>ChessGame</code>, <code>PokerGame</code> derive <code>Game</code>.</li>
<li>A <code>LoadGame</code> factory returns <code>std::shared_ptr&lt;Game&gt;</code> so that it can hand out either a ChessGame or PokerGame as a <code>Game</code>.</li>
</ul>
<p><strong>Pybind11 binding:</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-1" tabindex="-1"></a>PYBIND11_MODULE<span class="op">(</span>mygames<span class="op">,</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-2" tabindex="-1"></a>    <span class="co">// Trampoline class for Game to allow Python overrides</span></span>
<span id="cb24-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-3" tabindex="-1"></a>    <span class="kw">struct</span> PyGame <span class="op">:</span> Game<span class="op">,</span> py<span class="op">::</span>trampoline_self_life_support <span class="op">{</span></span>
<span id="cb24-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-4" tabindex="-1"></a>        <span class="kw">using</span> Game<span class="op">::</span>Game<span class="op">;</span> <span class="co">// inherit constructors if any</span></span>
<span id="cb24-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-5" tabindex="-1"></a></span>
<span id="cb24-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-6" tabindex="-1"></a>        <span class="dt">void</span> play<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-7" tabindex="-1"></a>            PYBIND11_OVERRIDE_PURE<span class="op">(</span><span class="dt">void</span><span class="op">,</span> Game<span class="op">,</span> play<span class="op">,</span> <span class="co">/* no args */</span><span class="op">);</span></span>
<span id="cb24-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-8" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-9" tabindex="-1"></a>        <span class="bu">std::</span>string name<span class="op">()</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb24-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-10" tabindex="-1"></a>            PYBIND11_OVERRIDE_PURE<span class="op">(</span><span class="bu">std::</span>string<span class="op">,</span> Game<span class="op">,</span> name<span class="op">,</span> <span class="co">/* no args */</span><span class="op">);</span></span>
<span id="cb24-11"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-11" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-12"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-12" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-13"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-13" tabindex="-1"></a></span>
<span id="cb24-14"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-14" tabindex="-1"></a>    py<span class="op">::</span><span class="va">class_</span><span class="op">&lt;</span>Game<span class="op">,</span> PyGame<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Game<span class="op">&gt;&gt;(</span>m<span class="op">,</span> <span class="st">&quot;Game&quot;</span><span class="op">)</span></span>
<span id="cb24-15"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-15" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span><span class="st">&quot;play&quot;</span><span class="op">,</span> <span class="op">&amp;</span>Game<span class="op">::</span>play<span class="op">)</span></span>
<span id="cb24-16"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-16" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span><span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="op">&amp;</span>Game<span class="op">::</span>name<span class="op">);</span></span>
<span id="cb24-17"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-17" tabindex="-1"></a>        <span class="co">// (If Game had a constructor or factory method, we might use py::init or def_static here)</span></span>
<span id="cb24-18"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-18" tabindex="-1"></a></span>
<span id="cb24-19"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-19" tabindex="-1"></a>    py<span class="op">::</span><span class="va">class_</span><span class="op">&lt;</span>ChessGame<span class="op">,</span> Game<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>ChessGame<span class="op">&gt;&gt;(</span>m<span class="op">,</span> <span class="st">&quot;ChessGame&quot;</span><span class="op">)</span></span>
<span id="cb24-20"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-20" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span>py<span class="op">::</span>init<span class="op">&lt;&gt;());</span>  <span class="co">// assuming it’s default constructible</span></span>
<span id="cb24-21"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-21" tabindex="-1"></a>    py<span class="op">::</span><span class="va">class_</span><span class="op">&lt;</span>PokerGame<span class="op">,</span> Game<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>PokerGame<span class="op">&gt;&gt;(</span>m<span class="op">,</span> <span class="st">&quot;PokerGame&quot;</span><span class="op">)</span></span>
<span id="cb24-22"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-22" tabindex="-1"></a>        <span class="op">.</span>def<span class="op">(</span>py<span class="op">::</span>init<span class="op">&lt;&gt;());</span></span>
<span id="cb24-23"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-23" tabindex="-1"></a></span>
<span id="cb24-24"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-24" tabindex="-1"></a>    m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;load_game&quot;</span><span class="op">,</span> <span class="op">&amp;</span>LoadGame<span class="op">,</span> py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;name&quot;</span><span class="op">));</span></span>
<span id="cb24-25"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb24-25" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>What this achieves:</strong></p>
<ul>
<li><p>You can call in Python:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb25-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb25-1" tabindex="-1"></a><span class="im">import</span> mygames</span>
<span id="cb25-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb25-2" tabindex="-1"></a>game <span class="op">=</span> mygames.load_game(<span class="st">&quot;chess&quot;</span>)   <span class="co"># this returns a mygames.Game instance (backed by ChessGame)</span></span>
<span id="cb25-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb25-3" tabindex="-1"></a><span class="bu">print</span>(game.name())                 <span class="co"># &quot;Chess&quot;  (calls ChessGame::name)</span></span>
<span id="cb25-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb25-4" tabindex="-1"></a>game.play()                        <span class="co"># invokes ChessGame::play(), prints &quot;Playing chess&quot;</span></span>
<span id="cb25-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb25-5" tabindex="-1"></a><span class="bu">isinstance</span>(game, mygames.Game)     <span class="co"># True</span></span>
<span id="cb25-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb25-6" tabindex="-1"></a><span class="bu">isinstance</span>(game, mygames.ChessGame) <span class="co"># True as well, since we bound ChessGame class</span></span></code></pre></div>
<p>The object is an instance of <code>ChessGame</code> (and also recognized as a <code>Game</code> since <code>ChessGame</code> is subclass of <code>Game</code> in Python too). If we hadn’t exposed <code>ChessGame</code> in pybind, it would appear only as <code>Game</code> type to Python, which is fine because the methods are all on <code>Game</code>. Exposing the derived class allows for <code>isinstance</code> checks or downcasting in Python if needed.</p></li>
<li><p>If the Python user tries to create their own game:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb26-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-1" tabindex="-1"></a><span class="kw">class</span> MyGame(mygames.Game):</span>
<span id="cb26-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-2" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb26-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-3" tabindex="-1"></a>        mygames.Game.<span class="fu">__init__</span>(<span class="va">self</span>)  <span class="co"># call base constructor (even if none, pybind will construct PyGame part)</span></span>
<span id="cb26-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-4" tabindex="-1"></a>    <span class="kw">def</span> name(<span class="va">self</span>):</span>
<span id="cb26-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-5" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;Mine&quot;</span></span>
<span id="cb26-6"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-6" tabindex="-1"></a>    <span class="kw">def</span> play(<span class="va">self</span>):</span>
<span id="cb26-7"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-7" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Playing my custom game&quot;</span>)</span>
<span id="cb26-8"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-8" tabindex="-1"></a></span>
<span id="cb26-9"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-9" tabindex="-1"></a>g2 <span class="op">=</span> MyGame()</span>
<span id="cb26-10"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-10" tabindex="-1"></a><span class="bu">print</span>(g2.name())  <span class="co"># &quot;Mine&quot;</span></span>
<span id="cb26-11"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb26-11" tabindex="-1"></a>g2.play()         <span class="co"># prints &quot;Playing my custom game&quot;</span></span></code></pre></div>
<p>This works because our binding used the trampoline <code>PyGame</code> which routes virtual calls. If C++ code (in the library) later calls a virtual method on a <code>Game</code> pointer that actually points to a <code>MyGame</code> (Python) instance, it will call into Python. For example, if there’s a C++ function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb27-1" tabindex="-1"></a><span class="dt">void</span> Tournament<span class="op">(</span>Game<span class="op">*</span> game1<span class="op">,</span> Game<span class="op">*</span> game2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb27-2" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Starting games: &quot;</span> <span class="op">&lt;&lt;</span> game1<span class="op">-&gt;</span>name<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; vs &quot;</span> <span class="op">&lt;&lt;</span> game2<span class="op">-&gt;</span>name<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb27-3"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb27-3" tabindex="-1"></a>    game1<span class="op">-&gt;</span>play<span class="op">();</span></span>
<span id="cb27-4"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb27-4" tabindex="-1"></a>    game2<span class="op">-&gt;</span>play<span class="op">();</span></span>
<span id="cb27-5"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb27-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and we bind that as <code>m.def("tournament", &amp;Tournament)</code>, then in Python:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb28-1"><a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#cb28-1" tabindex="-1"></a>mygames.tournament(mygame_instance, mygames.load_game(<span class="st">&quot;poker&quot;</span>))</span></code></pre></div>
<p>will call <code>MyGame.name()</code> (Python) for the first game and <code>PokerGame::name()</code> (C++) for the second, etc. Pybind11’s trampolines and holders ensure that the Python object <code>mygame_instance</code> stays alive during this call and that the virtual dispatch works correctly. (Under the hood, <code>tournament</code> receives a <code>Game*</code>. If that was created in Python, pybind11 actually passes a pointer to the <code>PyGame</code> object, whose virtual <code>play()</code> calls <code>PYBIND11_OVERRIDE</code> to go back to Python.)</p></li>
</ul>
<p><strong>Lifetime considerations:</strong> In the above, we used <code>std::shared_ptr&lt;Game&gt;</code> everywhere. This means both C++ and Python are sharing ownership. If <code>load_game("chess")</code> creates a shared_ptr and returns it to Python, Python’s object holds one reference; if you also keep one in C++ (maybe in a global or somewhere), the object lives until both are done. If Python deletes its reference (object goes out of scope) but C++ still has one, the object lives (but Python no longer can access it unless you passed it back). This shared ownership model is usually what you want for game environments, etc., to avoid premature deletion.</p>
<p>If your design instead had unique ownership (say the C++ side strictly manages lifetime and Python should not extend it), you could use <code>py::nodelete</code> or other strategies, but that’s advanced and rarely needed for typical use.</p>
<p><strong>Summary of best practices for pybind11 in this context:</strong></p>
<ul>
<li><strong>Use appropriate holder types</strong> (<code>std::shared_ptr</code> or <code>py::smart_holder</code>) for classes to simplify memory management and polymorphism. This avoids manual <code>new</code>/<code>delete</code> management and makes C++ polymorphic objects behave well in Python.</li>
<li><strong>Expose base classes and derived classes</strong> with proper inheritance in bindings so that Python knows the relationships. This enables Python to upcast automatically and call the correct methods.</li>
<li><strong>Bind factory functions</strong> in a way that returns ownership to Python. If using shared_ptr, it’s seamless. If using raw pointers, use <code>return_value_policy</code> to avoid memory leaks or double frees (e.g., <code>return_value_policy::take_ownership</code> if the function returns a new heap object).</li>
<li><strong>Trampolines for virtual overrides:</strong> Use them if and only if you need Python to override C++ virtual methods. Implement trampolines carefully for each virtual function. Remember to include <code>py::trampoline_self_life_support</code> in the inheritance to prevent slicing issues.</li>
<li><strong>Keep alive any cross-boundary pointers:</strong> If C++ holds onto a Python-created object, use <code>keep_alive</code> or ensure the Python object is referenced somewhere in Python. If Python holds a C++ object created via factory, use smart pointers (as we did) so that C++ doesn’t accidentally free it while Python still uses it.</li>
<li><strong>Testing the interface:</strong> It’s helpful to write some test code in Python to ensure that methods dispatch correctly (especially virtuals) and that no lifetime issues appear (e.g., use a Python subclass in a C++ function and see if it works, as in the tournament example).</li>
<li><strong>Documentation and clarity:</strong> Consider naming conventions in Python API – e.g., factory function names (<code>load_game</code>) should be pythonic (lowercase with underscore, as we did). Pybind11 allows you to add docstrings as well. And because C++ exceptions will translate to Python exceptions, ensure you handle errors (like unknown game type) by throwing C++ exceptions, which pybind will turn into Python <code>RuntimeError</code> or such.</li>
</ul>
<p>By following these practices, you can create Python bindings that feel natural to Python users while harnessing a robust C++ backend. A user can create and use <code>Game</code> objects in Python without worrying that they’re C++ under the hood – method calls Just Work, polymorphism Just Works. Meanwhile, you maintain the performance-critical parts in C++, and you can even allow power-users to extend functionality in Python via subclassing, thanks to trampolines and pybind11’s support.</p>
<p>This setup (C++ core + pybind11 interface) is common in many advanced projects (OpenSpiel, PyTorch, etc.). It does have a learning curve, but once mastered, it provides an <strong>“orienting view”</strong> of designing software that spans C++ and Python: write the heavy logic in C++ (with modern C++ best practices as discussed), expose a clean API to Python, and manage lifetimes carefully so that the two languages interact safely. With these tools – smart pointers, CMake build with scikit-build, pybind11 for binding, and good software design patterns – you’ll be well-equipped to develop performant, safe, and user-friendly C++/Python hybrid projects.</p>
<p><strong>Sources:</strong></p>
<ul>
<li>Factory Method pattern concept and usage; when (not) to use factories.</li>
<li>Modern C++ safe practices: prefer high-level constructs (STL containers/algorithms) over low-level pointers; avoid manual memory management, use RAII and smart pointers.</li>
<li>Eigen library for linear algebra (popular in ML, used by TensorFlow/Stan) and high-performance kernels.</li>
<li>Pybind11 advanced features: smart_holder for safe pointer passing; keep_alive usage to maintain object lifetimes; trampoline (virtual override) setup; general pybind11 class binding mechanics.</li>
</ul>
</div>
</div>
<div id="c-history" class="section level2 unnumbered hasAnchor">
<h2>C++ history<a href="factory-methods-modern-c-practices-and-pybind11-for-polymorphic-interfaces.html#c-history" class="anchor-section" aria-label="Anchor link to header"></a></h2>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="understanding-smart-pointers-in-c-history-problems-solved-and-best-practices.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="bibliography.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
